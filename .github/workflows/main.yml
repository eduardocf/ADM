name: Build and Publish Dependency Graph

on:
  #schedule:
  #  - cron: '*/5 * * * *'
  workflow_dispatch:

jobs:
  dependency-map:
    runs-on: windows-latest

    steps:
      - name: Checkout orchestrator repo
        uses: actions/checkout@v3

      - name: Clone application repositories
        shell: pwsh
        run: |
          $repos = @("Application01", "Application02", "Application03", "Application04", "Application05")
          foreach ($repo in $repos) {
            git clone https://x-access-token:${{ secrets.GH_PAT }}@github.com/eduardocf/$repo.git
          }

      - name: Extract all dependencies including config-based APIs
        shell: pwsh
        run: |
          # Recursive function to extract all URLs
          function Get-UrlsFromJson($obj) {
            $found = @()
            if ($obj -is [string] -and $obj -match '^https?://') {
              $found += $obj
            } elseif ($obj -is [hashtable]) {
              foreach ($val in $obj.Values) {
                $found += Get-UrlsFromJson $val
              }
            } elseif ($obj -is [System.Collections.IEnumerable]) {
              foreach ($item in $obj) {
                $found += Get-UrlsFromJson $item
              }
            }
            Write-Warning "$($found): $_"
            return $found
          }

          $repos = @("Application01", "Application02", "Application03", "Application04", "Application05")
          $results = @()

          foreach ($repo in $repos) {
            Set-Location $repo
            $projectName = $repo
            $nuget = @()
            $dll = @()
            $apis = @()

            $csproj = Get-ChildItem -Recurse -Filter *.csproj | Select-Object -First 1
            if ($csproj) {
              $projectName = Split-Path $csproj.Directory.FullName -Leaf
            }

            Get-ChildItem -Recurse -Filter *.csproj | ForEach-Object {
              [xml]$xml = Get-Content $_.FullName
              $nuget += $xml.Project.ItemGroup.PackageReference | ForEach-Object { $_.Include }
              $dll += $xml.Project.ItemGroup.COMReference | ForEach-Object { $_.Include }
              $dll += $xml.Project.ItemGroup.Reference |
                Where-Object { $_.Include -match "Application" -or $_.HintPath -match "Application" } |
                ForEach-Object { $_.Include }
            }

            Get-ChildItem -Recurse -Filter packages.config | ForEach-Object {
              [xml]$xml = Get-Content $_.FullName
              $nuget += $xml.packages.package | ForEach-Object { $_.id }
            }

            Get-ChildItem -Recurse -Include *.config | ForEach-Object {
              try {
                [xml]$xml = Get-Content $_.FullName
                $settings = $xml.SelectNodes("//appSettings/add") | Where-Object { $_.value -match '^https?://' }
                $settings | ForEach-Object { $apis += $_.value }
              } catch {}
            }

            Get-ChildItem -Recurse -Filter appsettings.json | ForEach-Object {
              try {
                $raw = Get-Content $_.FullName -Raw
                if ($raw -ne $null) {
                  $json = $raw | ConvertFrom-Json
                  $urls = Get-UrlsFromJson $json
                  $apis += $urls
                } 
                else {
                  Write-Warning "null content on "
                  Write-Warning "null content on $($_.FullName): $_"
                }
              } catch {
                  Write-Warning "Failed to parse $($_.FullName): $_"
              }
            }

            $results += [PSCustomObject]@{
              project = $projectName
              nuget = $nuget | Sort-Object -Unique
              dll = $dll | Sort-Object -Unique
              api = $apis | Sort-Object -Unique
            }

            Set-Location ..
          }

          $results | ConvertTo-Json -Depth 5 | Out-File dependencies.json -Encoding utf8

      - name: Upload dependencies.json (debug preview)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: extracted-dependencies
          path: dependencies.json

      - name: Generate styled .dot file
        shell: pwsh
        run: |
          $json = Get-Content dependencies.json | ConvertFrom-Json
          $dot = @(
            'digraph Dependencies {',
            '  node[shape=ellipse style="rounded,filled" color="lightgoldenrodyellow" ]'
          )
          $declared = @{}

          foreach ($item in $json) {
            $app = $item.project
            $declared[$app] = $true

            foreach ($pkg in $item.nuget) {
              if ($pkg) {
                $dot += '  "' + $app + '" -> "' + $pkg + '" [color=black];'
                $dot += '  "' + $pkg + '" [shape=box, color="#e6f0ff"];'
                $declared[$pkg] = $true
              }
            }

            foreach ($dll in $item.dll) {
              if ($dll) {
                $dot += '  "' + $app + '" -> "' + $dll + '" [color=blue];'
                $dot += '  "' + $dll + '" [shape=ellipse, color="lightgoldenrodyellow"];'
                $declared[$dll] = $true
              }
            }

            foreach ($url in $item.api) {
              if ($url) {
                try { $domain = ([System.Uri]$url).Host } catch { $domain = $url }
                $dot += '  "' + $app + '" -> "' + $domain + '" [color=black];'
                $dot += '  "' + $domain + '" [shape=diamond, color="#eafaf1"];'
                $declared[$domain] = $true
              }
            }
          }

          foreach ($node in $declared.Keys | Sort-Object) {
            if (-not ($dot -join "`n" -match '"' + [regex]::Escape($node) + '"')) {
              $dot += '  "' + $node + '";'
            }
          }

          $dot += '}'
          New-Item -ItemType Directory -Force -Path artifacts | Out-Null
          $dot | Out-File artifacts/dependency_graph.dot -Encoding utf8
          Move-Item dependencies.json artifacts/

      - name: Install Graphviz and render SVG
        run: |
          choco install graphviz -y
          dot -Tsvg artifacts/dependency_graph.dot -o artifacts/graph.svg

      - name: Generate index.html with inline SVG
        shell: pwsh
        run: |
          $svg = Get-Content artifacts/graph.svg -Raw
          $html = @"
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset='utf-8'>
            <title>Dependency Graph</title>
            <style>
              body { font-family: 'Segoe UI', sans-serif; background: #f5f5f5; text-align: center; margin: 0; padding: 2rem; }
              header { background: #0366d6; color: white; padding: 1rem; }
              svg { max-width: 100%; height: auto; background: white; border: 1px solid #ccc; box-shadow: 0 0 12px rgba(0,0,0,0.1); margin-top: 2rem; }
              footer { margin-top: 2rem; color: #777; font-size: 0.85rem; }
            </style>
          </head>
          <body>
            <header>
              <h1>ðŸ“Š Application Dependency Graph</h1>
              <p>NuGet â€¢ DLL â€¢ External APIs (by domain)</p>
            </header>
            $svg
            <footer>Generated via GitHub Actions & Graphviz</footer>
          </body>
          </html>
          "@
          $html | Out-File artifacts/index.html -Encoding utf8

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: ./artifacts